# Configurações de Ambientes - SOAT API
# Este arquivo centraliza as configurações para diferentes ambientes

environments:
  dev:
    namespace: soat-api-dev
    replicas: 1
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "256Mi"
        cpu: "200m"
    hpa:
      minReplicas: 1
      maxReplicas: 3
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    config:
      NODE_ENV: "development"
      LOG_LEVEL: "debug"
      API_BASE_URL: "https://dev-api.soat.com"
      DB_HOST: "postgres-dev"
      DB_PORT: "5432"
      DB_DATABASE: "fastfood_dev"
    secrets:
      DB_PASSWORD: "dev-password"
      MERCADO_PAGO_ACCESS_TOKEN: "TEST-DEV-TOKEN"
      JWT_SECRET: "dev-jwt-secret-key"
      WEBHOOK_SECRET: "dev-webhook-secret"
    ingress:
      host: "dev-api.soat.com"
      tls: false
      annotations:
        nginx.ingress.kubernetes.io/rate-limit: "100"
        nginx.ingress.kubernetes.io/rate-limit-window: "1m"

  staging:
    namespace: soat-api-staging
    replicas: 2
    resources:
      requests:
        memory: "256Mi"
        cpu: "200m"
      limits:
        memory: "512Mi"
        cpu: "400m"
    hpa:
      minReplicas: 2
      maxReplicas: 5
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    config:
      NODE_ENV: "staging"
      LOG_LEVEL: "info"
      API_BASE_URL: "https://staging-api.soat.com"
      DB_HOST: "postgres-staging"
      DB_PORT: "5432"
      DB_DATABASE: "fastfood_staging"
    secrets:
      DB_PASSWORD: "staging-password"
      MERCADO_PAGO_ACCESS_TOKEN: "TEST-STAGING-TOKEN"
      JWT_SECRET: "staging-jwt-secret-key"
      WEBHOOK_SECRET: "staging-webhook-secret"
    ingress:
      host: "staging-api.soat.com"
      tls: true
      annotations:
        nginx.ingress.kubernetes.io/rate-limit: "200"
        nginx.ingress.kubernetes.io/rate-limit-window: "1m"
        cert-manager.io/cluster-issuer: "letsencrypt-prod"

  prod:
    namespace: soat-api-prod
    replicas: 5
    resources:
      requests:
        memory: "512Mi"
        cpu: "500m"
      limits:
        memory: "1Gi"
        cpu: "1000m"
    hpa:
      minReplicas: 5
      maxReplicas: 20
      targetCPUUtilizationPercentage: 70
      targetMemoryUtilizationPercentage: 80
    config:
      NODE_ENV: "production"
      LOG_LEVEL: "warn"
      API_BASE_URL: "https://api.soat.com"
      DB_HOST: "postgres-prod"
      DB_PORT: "5432"
      DB_DATABASE: "fastfood_prod"
    secrets:
      DB_PASSWORD: "prod-password"
      MERCADO_PAGO_ACCESS_TOKEN: "PROD-ACCESS-TOKEN"
      JWT_SECRET: "prod-jwt-secret-key"
      WEBHOOK_SECRET: "prod-webhook-secret"
    ingress:
      host: "api.soat.com"
      tls: true
      annotations:
        nginx.ingress.kubernetes.io/rate-limit: "100"
        nginx.ingress.kubernetes.io/rate-limit-window: "1m"
        cert-manager.io/cluster-issuer: "letsencrypt-prod"
        nginx.ingress.kubernetes.io/cors-allow-origin: "https://soat.com"
        nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
        nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization"

# Configurações globais
global:
  image:
    repository: soat-api
    tag: latest
    pullPolicy: Always
  
  database:
    type: postgresql
    version: "13"
    port: 5432
  
  monitoring:
    enabled: true
    prometheus:
      enabled: true
      scrapeInterval: "30s"
    grafana:
      enabled: true
      dashboard: "soat-api-dashboard"
  
  security:
    podSecurityPolicy:
      enabled: true
      runAsNonRoot: true
      runAsUser: 1000
      readOnlyRootFilesystem: true
    
    networkPolicy:
      enabled: true
      ingress:
        - from:
            - namespaceSelector:
                matchLabels:
                  name: ingress-nginx
          ports:
            - protocol: TCP
              port: 3000
    
    secrets:
      externalSecretsOperator:
        enabled: false
        backend: "aws-secrets-manager"
  
  backup:
    enabled: true
    schedule: "0 2 * * *"  # 2 AM daily
    retention: "30d"
    storage:
      type: "s3"
      bucket: "soat-api-backups"
  
  scaling:
    verticalPodAutoscaler:
      enabled: true
      minCPU: "100m"
      maxCPU: "1000m"
      minMemory: "128Mi"
      maxMemory: "1Gi"
    
    clusterAutoscaler:
      enabled: true
      scaleDownDelayAfterAdd: "10m"
      scaleDownUnneeded: "10m"

# Configurações de rede
network:
  service:
    type: ClusterIP
    port: 3000
    targetPort: 3000
  
  ingress:
    className: nginx
    annotations:
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
      nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
      nginx.ingress.kubernetes.io/proxy-body-size: "10m"
      nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
      nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
      nginx.ingress.kubernetes.io/proxy-read-timeout: "60"

# Configurações de logs
logging:
  fluentd:
    enabled: true
    config:
      - name: fluentd-config
        data:
          fluent.conf: |
            <source>
              @type tail
              path /var/log/containers/*.log
              pos_file /var/log/fluentd-containers.log.pos
              tag kubernetes.*
              read_from_head true
              <parse>
                @type json
                time_format %Y-%m-%dT%H:%M:%S.%NZ
              </parse>
            </source>
            
            <filter kubernetes.**>
              @type kubernetes_metadata
            </filter>
            
            <match kubernetes.**>
              @type elasticsearch
              host elasticsearch-master
              port 9200
              logstash_format true
              logstash_prefix k8s
              <buffer>
                @type file
                path /var/log/fluentd-buffers/kubernetes.system.buffer
                flush_mode interval
                retry_type exponential_backoff
                flush_interval 5s
                retry_forever false
                retry_max_interval 30
                chunk_limit_size 2M
                queue_limit_length 8
                overflow_action block
              </buffer>
            </match>
  
  elasticsearch:
    enabled: true
    replicas: 3
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "1000m"
  
  kibana:
    enabled: true
    replicas: 1
    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "500m"

# Configurações de alertas
alerts:
  prometheus:
    enabled: true
    rules:
      - name: soat-api-rules
        groups:
          - name: soat-api
            rules:
              - alert: HighCPUUsage
                expr: container_cpu_usage_seconds_total{container="soat-api"} > 0.8
                for: 5m
                labels:
                  severity: warning
                annotations:
                  summary: "High CPU usage detected"
                  description: "Container {{ $labels.container }} has high CPU usage"
              
              - alert: HighMemoryUsage
                expr: container_memory_usage_bytes{container="soat-api"} > 0.8
                for: 5m
                labels:
                  severity: warning
                annotations:
                  summary: "High memory usage detected"
                  description: "Container {{ $labels.container }} has high memory usage"
              
              - alert: PodDown
                expr: up{container="soat-api"} == 0
                for: 1m
                labels:
                  severity: critical
                annotations:
                  summary: "Pod is down"
                  description: "Pod {{ $labels.pod }} is down"
  
  grafana:
    enabled: true
    dashboards:
      - name: soat-api-dashboard
        title: "SOAT API Dashboard"
        panels:
          - title: "CPU Usage"
            type: graph
            targets:
              - expr: container_cpu_usage_seconds_total{container="soat-api"}
          - title: "Memory Usage"
            type: graph
            targets:
              - expr: container_memory_usage_bytes{container="soat-api"}
          - title: "HTTP Requests"
            type: graph
            targets:
              - expr: http_requests_total{container="soat-api"} 